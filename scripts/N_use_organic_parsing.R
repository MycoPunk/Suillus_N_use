###################################################################################
#genome-mining to characterize the distribution and conservation of genes involved in the liberation and catabolism  
#of organic nitrogen across 6 genome-sequenced Suillus strains targeting Chitin (CAZymes), and Protein (Proteases)

#inputs were generated using: 
#Orthogroups generated using OrthoFinder 2.0
#BLAST matches to the MEROPS scan database (v. 12.5)
#CAZymes as defined by the JGI annotation pipeline, and in in-house substrate specificity database
#tree generated using Phyling and IQtree
#annotations were generated by MEROPS or JGI and linked to individual OGs using in house-scripts
#all associated code can be found on in the git repo https://github.com/MycoPunk/Suillus_N_use
###################################################################################


#set packages 
library(data.table)
library(tidyverse)
library(hrbrthemes)
library(forcats)
library(ggforce)
library(ggimage)
library(ggtree)
library(ape)
library(phytools)
library(ggplot2)
library(ggpubr)
library(vegan)
library(quadprog)
library(devtools)
library(phangorn)
library(gridExtra)
library(circlize)
library(treeio)
library(ComplexHeatmap)
library(ComplexUpset)
sessionInfo()

##set seed for reproducibility
set.seed(666)

#Set variables 
n_Suillus_genomes= 6
setwd("~/Desktop/Project_N_use")

#read in data
OF.gene_families<-as.data.frame(fread("Orthogroups.tsv")) #main OG file
OF.unassigned<- as.data.frame(fread("Orthogroups_UnassignedGenes.tsv")) #singleton OGs
MEROPS<- as.data.frame(fread("data/MEROPS.OUT.PEPTIDASE.aa.fasta", header = FALSE, sep = "\t")) #MEROPS BLASTP results
names(MEROPS)<- c("Orthogroup", "sseqid", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "start", "send", "evalue", "bitscore")
MEROPS_anno<-as.data.frame(fread("data/merops_anno_map.txt", header = FALSE)) #this was generated from subsetting the fasta headers of the MEROPS scan database, using the scrip N_USE_PROT_02_make_annotation_map_for_MEROPS.sh
names(MEROPS_anno)<- c("sseqid","anno", "MEROPS_ID")
CAZy<- as.data.frame(fread("CAZYs_all.csv")) #CAZymes as annotated by the JGI pipeline 
tree<- read.tree("Suillus.6_taxa.iqtree") #Tree generated using PHYling and IQ tree 
CAZY_MAP<- read_csv("CAZY_annotation_database_5Aug2024.csv") #from MycoCosm

#names mapping file from JGI codes to display names for the manuscript
names_df<- data.frame(cbind(JGI_code = c("Suicli1", "Suipic1", "Suiame1", "Suigr1", "Suilu4", "Suiamp1"), 
                            manuscript_name = c("S. clintonianus", "S. spraguei", "S. americanus", "S. weaverae", "S. luteus", "S. ampliporus")))


### Clean and process Data ###

#combine OF families with singletons
OF.gene_families_all<- rbind(OF.gene_families, OF.unassigned)
#clean up 
rm(OF.gene_families)
rm(OF.unassigned)

##basic stats
#how many gene families are there?
n_gene_fams_all<- nrow(OF.gene_families_all)
n_gene_fams_all
#22,006

##fix names 
#remove .aa
names(OF.gene_families_all)<- sapply(names(OF.gene_families_all), gsub, pattern = ".aa", replacement = "" )
#create a named vector to rename with
rename_vector <- setNames(names_df$manuscript_name, names_df$JGI_code)
#rename the columns in OF.gene_families_all
OF.gene_families_all <- OF.gene_families_all %>% 
  rename_at(vars(names(rename_vector)), ~ rename_vector[.])

#names of cols to exclude to run numbers
cols_to_exclude<- "Orthogroup"
strains_only<- OF.gene_families_all[,!names(OF.gene_families_all) %in% cols_to_exclude]
strain_names<- names(strains_only)

#make sure all strains accounted for
length(unique(strain_names)) 
#6

##add number_genomes column to get totals
#first replace blank calls with NAs
strains_only<- apply(strains_only, 2, function(x) gsub("^$|^ $", NA, x))
OF.gene_families_all$number_genomes_all<- rowSums(!is.na(strains_only)) #cols that are not blank
#replace blanks with NAs for all
OF.gene_families_all<- data.frame(apply(OF.gene_families_all, 2, function(x) gsub("^$|^ $", NA, x)), check.names=FALSE)
#change type to numeric
OF.gene_families_all$number_genomes_all <- as.numeric(as.character(OF.gene_families_all$number_genomes_all))


#how many of the gene families conserved across all 6 genomes?
n_gene_fams_core_all<- sum(OF.gene_families_all$number_genomes_all == n_Suillus_genomes)
n_gene_fams_core_all
#7,101 conserved in all 

#that's what % of the total?
(n_gene_fams_core_all*100)/n_gene_fams_all #32.27%

#how many of the gene families are singletons in Suillus
n_gene_fams_singletons<- sum(as.numeric(OF.gene_families_all$number_genomes_all) == 1)
n_gene_fams_singletons
#10,664

#that's what percent out of the total?
(n_gene_fams_singletons*100)/n_gene_fams_all
#48.46.13%




#### Protein-active gene analysis using MEROPS database annotations ####

##pan-genus conservation analysis
#subset MEROPS hits to only the top hit per OG
MEROPS_top_hits<- MEROPS %>%
  group_by(Orthogroup) %>%
  slice(which.min(evalue)) %>%
  ungroup()

#subset OGs to only those with BLAST hits to MEROPS database
MEROPS_subset<- semi_join(OF.gene_families_all, MEROPS_top_hits, by = "Orthogroup")
nrow(MEROPS_subset) #there are 342 OGs with hits to the MEROPS database. 

#how many conserved? (core MEROPS)
total_core<- sum(MEROPS_subset$number_genomes_all == 6)
total_core #224 
nrow(MEROPS_subset) - total_core #so 118 are singletons or accessory 
total_singletons<- sum(MEROPS_subset$number_genomes_all == 1)
total_singletons #76 singles

#order species by abundance of Prot genes
cols_to_exclude<- c("Orthogroup", "number_genomes_all")

##which strain has the highest/lowest number of singletons and accessory gene fams? 
MEROPS_subset_counts_only<- MEROPS_subset[,!names(MEROPS_subset) %in% cols_to_exclude]

##make binary (if gene = 1, if not = 0)
#replace all NAs with 0s
MEROPS_subset_counts_only[is.na(MEROPS_subset_counts_only)] <- 0
#fill in ones
MEROPS_subset_counts_only_ones<- as.data.frame(replace(MEROPS_subset_counts_only, MEROPS_subset_counts_only!="0", 1))
#change to numeric
MEROPS_subset_counts_only_ones_num <- mutate_all(MEROPS_subset_counts_only_ones, function(x) as.numeric(as.character(x)))

#subset to remove core genes from accessory and singletons 
no_core<- MEROPS_subset_counts_only_ones_num[rowSums(MEROPS_subset_counts_only_ones_num) != 6,]
rowSums(no_core)
no_core_or_singles<-no_core[rowSums(no_core) != 1,]
rowSums(no_core_or_singles)

#subset to get singletons only
singles_only<-no_core[rowSums(no_core) == 1,]

#subset to remove core genes from accessory and singletons 
core_only<- MEROPS_subset_counts_only_ones_num[rowSums(MEROPS_subset_counts_only_ones_num) == 6,]
rowSums(core_only)

##get MEROPS gene counts per species 
counts_overall<- colSums(MEROPS_subset_counts_only_ones_num)
sort(counts_overall)

#S. luteus   S. ampliporus   S. americanus     S. weaverae S. clintonianus     S. spraguei 
#252             253             255             255             260             302 


#core MEROPS genes only
counts_core<- colSums(core_only)
sort(counts_core) #224 are conserved completely (core)

#accessory MEROPS genes only
counts_acessory<- colSums(no_core_or_singles)
sort(counts_acessory)

#S. spraguei       S. luteus   S. ampliporus   S. americanus S. clintonianus     S. weaverae 
#18              24              25              30              30              30 

#singletons only
counts_singles<- colSums(singles_only)
sort(counts_singles)

#S. americanus     S. weaverae   S. ampliporus       S. luteus S. clintonianus     S. spraguei 
#1               1               4               4               6              60 


###compile counts for graphing 
MEROPS_counts<- t(data.frame(rbind(Core = counts_core,
                                   Acessory = counts_acessory, 
                                   Singeltons = counts_singles), check.names=FALSE))




#### PLOT MEROPS ONTO TREE ####
#root tree
plot(tree)
ggtree(tree)

#root
tree<- ape::root(tree, "Suiamp1", resolve.root = TRUE,
                 interactive = FALSE, edgelabel = FALSE)

plot(tree)
ggtree(tree)
tree$tip.label

tree<- ladderize(tree, right = TRUE)
plot(tree)

#print nodes to see which one needs rotating
plot(tree)
nodelabels() #10 needs rotating
tree <- ape::rotate(tree, node = 10)
#check
tree$tip.label[tree$edge[tree$edge[, 2] <= length(tree$tip.label), 2]]

plot(tree)
ggtree(tree)

##rename the tips to match the rest of the manuscript
#function to rename tips
rename_tips <- function(tree, names_df) {
  #make a named vector for renaming
  rename_vector <- setNames(names_df$manuscript_name, names_df$JGI_code)
  #rename the tips
  tree$tip.label <- sapply(tree$tip.label, function(x) {
    if (x %in% names(rename_vector)) {
      return(rename_vector[x])
    } else {
      return(x)
    }
  })
  
  return(tree)
}

#run rename function
tree <- rename_tips(tree, names_df)

#print the leaves in the order they appear (starting at the root) with new names
tip_order <- tree$tip.label[tree$edge[tree$edge[, 2] <= length(tree$tip.label), 2]]
tip_order

ggtree(tree)


#ggtee tip order
p <- ggtree(tree)

#extract the tip labels in the order they appear in the ggtree plot
tip_order <- p$data %>%
  filter(isTip) %>%
  arrange(y) %>%   # Arrange by y-axis position which corresponds to the vertical order in the plot
  pull(label)


##plot conservation distribution of MEROPS genes. 
#plot
#p<- ggtree(tree) + 
  #geom_treescale(x=2.5, y=NULL, color = NA)+
#  geom_text2(aes(subset = !isTip & !is.na(as.numeric(label)), label=label), hjust=1.2, size=2, nudge_y = .32)
#geom_text2(aes(label=label, subset = !is.na(as.numeric(label)) & as.numeric(label) & !isTip > 80, label.size = 0.25))
#p + geom_tiplab(size =3, 
#                align = TRUE, 
#                linesize = .25, 
#                linetype = 3, 
#                offset = .03)


##example of compound bar plot
# Get the stacked barplot
#barplot(t(as.matrix(MEROPS_counts)), 
#        col=colors()[c(23,89,12)] , 
#        border="white", 
#        space=0.04, 
#        font.axis=2, 
#        xlab="group")

#library(RColorBrewer)
#cols<-brewer.pal(3,"YlGnBu")


#Plot onto tree

##note - this is glitchy, if the tree is not showing up, run it with just (plotTree.barplot(tree, MEROPS_counts) and then with your params
#tree<-ladderize(tree, right = FALSE)
#plotTree.barplot(tree, MEROPS_counts)
#par(mfrow=c(1,2))
#plotTree.barplot(tree, MEROPS_counts, add = TRUE,
#                 args.plotTree=list(fsize=1, 
#                                    lwd=2, 
#                                    ftype="bi",
#                                    offset=.5,
#                                    use.edge.length = TRUE),
#                 args.barplot=list(xlab="# MEROPS", 
#                                   col=cols, 
#                                   mar=c(5.1,0,2.1,2.1),
#                                   legend.text=TRUE,args.legend = list(x = "bottomright", bty="n", xpd = TRUE)))
#plotTree.barplot(tree, MEROPS_counts, add=TRUE,
#                 args.plotTree=list(plot=FALSE),
#                 args.barplot=list(xlab="# CAZymes", 
#                                   col=cols, 
#                                   mar=c(5.1,0,2.1,2.1),
#                                   legend.text=TRUE,args.legend = list(x = "bottomright", bty="n", xpd = TRUE)))




##translate MEROPS_subset from gene names into gene counts
#first remove the last col with the totals
OF.gene_families_all_no_counts<- MEROPS_subset[, !(names(MEROPS_subset) %in% "number_genomes_all")]
#convert to counts
OF.gene_families_counts <- OF.gene_families_all_no_counts %>%
  mutate(across(-Orthogroup, ~ifelse(is.na(.), NA, as.character(str_count(., ",") + 1))))

##link annotations to OF.gene_families_counts -annotations from MEROPS
OF.gene_families_counts_anno <- OF.gene_families_counts %>%
  inner_join(MEROPS_top_hits %>% select(Orthogroup, sseqid), by = "Orthogroup") %>%
  select(Orthogroup, sseqid, everything()) #to set sseqid as the second column 

##link annotations to OF.gene_families_counts_anno from merops annotation file
OF.gene_families_counts_anno_mr <- OF.gene_families_counts_anno %>%
  inner_join(MEROPS_anno %>% select(sseqid, anno), by = "sseqid") %>%
  select(Orthogroup, anno, everything()) #to set anno as the second column 



###REFORMAT TO CAPTURE THE FAMILY-LEVEL ANNOTATIONS###

#split family information from the MEROPS_ID col - note this is the first letter. 
MEROPS_anno$family <- substr(MEROPS_anno$MEROPS_ID, 1, 1)

#make a key to the family annotations
family_key<- data.frame(cbind(key = c("A", "C", "G", "M", "N", "P", "S", "T", "U"), 
                   value = c("Aspartic", "Cysteine", "Glutamic", "Metallo", "Asparagine", "Mixed", "Serine", "Threonine", "Unknown")))
               
#check
setdiff((unique(MEROPS_anno$family)), family_key$key)
setdiff(family_key$key, unique(MEROPS_anno$family))

#add a 'family_text' column using merge, which uses the key values with the annotation "value" values
MEROPS_anno <- merge(MEROPS_anno, family_key, by.x = "family", by.y = "key", all.x = TRUE)

#rename the 'value' column to 'family_text'
names(MEROPS_anno)[names(MEROPS_anno) == "value"] <- "family_text"

#reorder and subset to remove unecesary columns
MEROPS_anno_clean <- MEROPS_anno[, c("sseqid", "anno", "family_text")]


#link family annotations 
OF.gene_families_counts_anno_mr_fam <- OF.gene_families_counts_anno_mr %>%
  inner_join(MEROPS_anno_clean %>% select(sseqid, family_text), by = "sseqid") %>%
  select(Orthogroup, anno, family_text, everything()) #to set anno as the second column 


#remove OG and sseq cols for graphing 
MEROPS_anno_counts <- OF.gene_families_counts_anno_mr_fam %>%
  select(-Orthogroup, -sseqid, -anno)

#change all to numeric except the first anno col
MEROPS_anno_counts[, -1] <- lapply(MEROPS_anno_counts[, -1], function(x) as.numeric(as.character(x)))

#condense annotation categories to merge duplicate annotations
df_condensed <- data.frame(MEROPS_anno_counts %>%
  group_by(family_text) %>%
  summarize(across(everything(), sum, na.rm = TRUE), .groups = 'drop'))
#fix column names
colnames(df_condensed) <- names(MEROPS_anno_counts)

#set row names to the annotation 
rownames(df_condensed) <- df_condensed[, 1]
#and remove the col
df_condensed <- df_condensed %>%
  select(-family_text)

#format for graphing
MEROPS_counts1<- t(df_condensed) #this is your input for graphing. - note, you probably have to scale this though. 


##graph MEROPS BY PROTEIN FAMILY##
#change datatype to matrix
MEROPS_counts1<- as.matrix(MEROPS_counts1)

#scale data for easier viewing - do this be category so the scale starts over for each color
#start by splitting each category
Aspartic <- MEROPS_counts1[, grep("Aspartic", colnames(MEROPS_counts1))]
Cysteine<- MEROPS_counts1[, grep("Cysteine", colnames(MEROPS_counts1))]
Metallo<- MEROPS_counts1[, grep("Metallo", colnames(MEROPS_counts1))]
Serine<- MEROPS_counts1[, grep("Serine", colnames(MEROPS_counts1))]
Threonine<- MEROPS_counts1[, grep("Threonine", colnames(MEROPS_counts1))]

#set color scale for each 
Aspartic_col_scale = colorRamp2(c(min(Aspartic)-2, max(Aspartic)), c("#FFFFFF", "#BF766F"))
Cysteine_col_scale = colorRamp2(c(min(Cysteine)-2, max(Cysteine)), c("#FFFFFF", "#D98032"))
Metallo_col_scale = colorRamp2(c(min(Metallo)-2, max(Metallo)), c("#FFFFFF", "#51718C"))
Serine_col_scale = colorRamp2(c(min(Serine)-2, max(Serine)), c("#FFFFFF", "#D9AF62"))
Threonine_col_scale = colorRamp2(c(min(Threonine)-2, max(Threonine)), c("#FFFFFF", "#604A70"))


colSums(MEROPS_counts1)

MEROPS_names2<- colnames(MEROPS_counts1)
desired_column_order <- c("Aspartic", "Cysteine", "Metallo", "Serine", "Threonine")


#Define the cell size
cell_size <- unit(7, "mm")  # Change this to your desired cell size


#find the correct row order based on tip_order
row_order <- rev(match(tip_order, rownames(MEROPS_counts1)))

# Create the heatmap
protein_fig <- Heatmap(
  MEROPS_counts1, 
  name = "relative abundance \nper MEROPS family", 
  rect_gp = gpar(type = "none", col = "white", lwd = 2),  # Set white borders around each cell
  column_title = "MEROPS", 
  column_title_side = "bottom",
  column_names_rot = 45,
  cluster_columns = FALSE,  # Keep columns in the same order as the original data matrix
  show_row_dend = FALSE,  # Hide the row dendrogram
  show_column_dend = FALSE,  # Hide the column dendrogram
  row_order = row_order,  # Correctly set the row order
  row_names_gp = gpar(fontface = "italic"),
  top_annotation = HeatmapAnnotation(
    "total per \nMEROPS family" = anno_points(colSums(MEROPS_counts1)),
    height = unit(15, "mm")
  ),  
  right_annotation = rowAnnotation(
    "total per \nspecies" = anno_barplot(rowSums(MEROPS_counts1), width = unit(20, "mm"))
  ), 
  height = nrow(MEROPS_counts1) * cell_size,  # Set height of cells
  width = ncol(MEROPS_counts1) * cell_size,   # Set width of cells
  
  column_split = factor(colnames(MEROPS_counts1), levels = desired_column_order),
  column_order = order(factor(colnames(MEROPS_counts1), levels = desired_column_order)),  # Set the column order here
  
  cell_fun = function(j, i, x, y, width, height, fill) {
    v <- as.matrix(MEROPS_counts1)[i, j]
    
    # Define the color scaling function based on column names
    col <- ifelse(MEROPS_names2[j] == "Aspartic", Aspartic_col_scale(v),
                  ifelse(MEROPS_names2[j] == "Cysteine", Cysteine_col_scale(v),
                         ifelse(MEROPS_names2[j] == "Metallo", Metallo_col_scale(v),
                                ifelse(MEROPS_names2[j] == "Serine", Serine_col_scale(v),
                                       ifelse(MEROPS_names2[j] == "Threonine", Threonine_col_scale(v),
                                              col_fun_c(v))))))
    
    grid.rect(x, y, width, height, gp = gpar(fill = col, col = col))
    
    # Add text here
    grid.text(sprintf("%d", as.matrix(MEROPS_counts1)[i, j]), x, y, 
              gp = gpar(fontsize = 10, col = "black"))
  }, 
  show_heatmap_legend = FALSE
)

# Print the heatmap
protein_fig

#pdf("protein_fig.pdf", width = 8, height = 4)
#draw(protein_fig)
#dev.off()



#### Make sup. figure of Aspartic protease annotations ####

##link annotations to OF.gene_families_counts_anno from merops annotation file
MEROPS_anno_w_family <- OF.gene_families_counts_anno_mr %>%
  inner_join(MEROPS_anno %>% select(sseqid, family), by = "sseqid") %>%
  select(Orthogroup, anno, family, everything()) #to set anno as the second column 

#subset to only Aspartic peptidases
MEROPS_anno_w_family_2<- subset(MEROPS_anno_w_family, family == "A")

#remove unnecessary cols
MEROPS_anno_w_family_3 <- MEROPS_anno_w_family_2 %>%
  select(-family, -sseqid)

##make sup table
#remove family col
MEROPS_anno_w_family_4 <- MEROPS_anno_w_family_3 %>%
  select(-Orthogroup)

#change all to numeric except the first anno col
MEROPS_anno_w_family_4[, -1] <- lapply(MEROPS_anno_w_family_4[, -1], function(x) as.numeric(as.character(x)))

#condense annotation categories to merge duplicate annotations
df_condensed <- data.frame(MEROPS_anno_w_family_4 %>%
  group_by(anno) %>%
  summarize(across(everything(), sum, na.rm = TRUE), .groups = 'drop'))
#fix column names
colnames(df_condensed) <- names(MEROPS_anno_w_family_4)

#reality check that these numbers match up with the previous graph
colSums(df_condensed[, -1]) #OK. looks good

#set row names to the annotation
rownames(df_condensed) <- df_condensed[, 1]
#and remove the col
df_condensed <- df_condensed %>%
select(-anno)

#Print table df_condensed as a supplemental 
#write.table(df_condensed, "SUP_table_Aspartic.txt", sep = "\t", row.names = TRUE, col.names = TRUE)


### Make upset plot ###
#subset to polyporopepsin OGs
polyporopepsin<- subset(MEROPS_anno_w_family_3, anno =="polyporopepsin")

#remove anno column
polyporopepsin <- polyporopepsin %>%
  select(-anno)

#convert to binary presence/absence matrix
df_binary <- polyporopepsin %>%
  mutate(across(`S. americanus`:`S. spraguei`, ~ ifelse(is.na(.), 0, 1)))

dim(df_binary) #there are 44 OGs that encode polyporopepsin

#select only the relevant columns for the UpSet plot (species columns)
df_upset <- df_binary %>% select(-Orthogroup)

#order
df_upset <- df_upset[, match(tip_order, colnames(df_upset)) ]

#render the UpSet plot of polyporopepsin
polyporopepsinupset<- ComplexUpset::upset(df_upset, tip_order, #set the order of the rows to match the tree
                        height_ratio=.2,
                        width_ratio=0.2,
                        sort_sets=FALSE,
                        stripes = "white",
                        name = "distribution of polyporopepsin OrthoGroups")


polyporopepsinupset


##make heatmap of polyporopepsin
#change to numeric
polyporopepsin[, -1] <- lapply(polyporopepsin[, -1], function(x) as.numeric(as.character(x)))

#set row names to the orthogroup 
rownames(polyporopepsin) <- polyporopepsin[, 1]
#and remove the col
polyporopepsin <- polyporopepsin %>%
  select(-Orthogroup)

#change NAs to 0
polyporopepsin[is.na(polyporopepsin)] <- 0

#change to matrix type
polyporopepsin<- as.matrix(t(polyporopepsin))

#find the correct row order based on tip_order
row_order <- rev(match(tip_order, rownames(polyporopepsin)))

#create color scale
Aspartic_col_scale2 = colorRamp2(c(min(polyporopepsin), max(polyporopepsin)), c("#FFFFFF", "#BF766F"))



#render heatmap of polyporopepsin
polyporopepsin_fig <- Heatmap(
  polyporopepsin, 
  col = Aspartic_col_scale2,
  name = "relative abundance \nper MEROPS family", 
  rect_gp = gpar(type = "none", col = "white", lwd = 2),  # Set white borders around each cell
  column_title = "MEROPS", 
  column_title_side = "bottom",
  column_names_rot = 45,
  cluster_columns = FALSE,  # Keep columns in the same order as the original data matrix
  show_row_dend = FALSE,  # Hide the row dendrogram
  show_column_dend = FALSE,  # Hide the column dendrogram
  row_order = row_order,  # Correctly set the row order
  row_names_gp = gpar(fontface = "italic"),
  top_annotation = HeatmapAnnotation(
    "total per \nMEROPS family" = anno_points(colSums(polyporopepsin)),
    height = unit(15, "mm")
  ),  
  right_annotation = rowAnnotation(
    "total per \nspecies" = anno_barplot(rowSums(polyporopepsin), width = unit(20, "mm"))
  ), 
  height = nrow(polyporopepsin) * cell_size,  # Set height of cells
  width = ncol(polyporopepsin) * cell_size,   # Set width of cells
  
  column_split = factor(colnames(polyporopepsin), levels = desired_column_order),
  column_order = order(factor(colnames(polyporopepsin), levels = desired_column_order)),  # Set the column order here
  
  cell_fun = function(j, i, x, y, width, height, fill) {
    v <- as.matrix(polyporopepsin)[i, j]
    
    grid.rect(x, y, width, height, 
              gp = gpar(fill = Aspartic_col_scale2(as.matrix(polyporopepsin)[i, j]), 
                        col = "white"))
    
    # Add text here
    grid.text(sprintf("%d", as.matrix(polyporopepsin)[i, j]), x, y, 
              gp = gpar(fontsize = 10, col = "black"))
  }, 
  show_heatmap_legend = FALSE
)

#print the heatmap
polyporopepsin_fig

#pdf("polyporopepsin_fig.pdf", width = 18, height = 4)
#draw(polyporopepsin_fig)
#dev.off()


### some quick stats about polyporopepsin ##

#extract S. spraguei
S_spra_polyporopepsin <- polyporopepsin["S. spraguei", ]

#how many polyporopepsin OGs in S. spraguei?
non_zero_count <- sum(S_spra_polyporopepsin != 0)
non_zero_count
ncol(polyporopepsin)

#How many overall?
MEROPS_anno_counts

#remove the family_text col to get totals
MEROPS_anno_counts_numonly <- MEROPS_anno_counts %>%
  select(-family_text)

#by species
sort(colSums(MEROPS_anno_counts_numonly, na.rm = TRUE))

#overall
sum(colSums(MEROPS_anno_counts_numonly, na.rm = TRUE))

#by catalytic mechanism
sort(colSums(MEROPS_counts1))





#### Chitin-active CAZYme analysis ####

##rename strains in the CAZy dataset
#rename the columns in OF.gene_families_all
CAZy_2 <- CAZy %>% 
  rename_at(vars(names(rename_vector)), ~ rename_vector[.])

#subset to only the species you need for this analysis 
strain_names_and_anno <- c(strain_names, "Annotation", "Annotation Description")
CAZy_subset_anno<- CAZy_2[, names(CAZy_2) %in% strain_names_and_anno]
CAZy_subset<- CAZy_2[, names(CAZy_2) %in% strain_names]

#format CAZy_subset like MEROPS_counts
CAZy_for_heat<- t(CAZy_subset_anno)
#first row should be column names
new_colnames <- as.character(CAZy_for_heat[1, ])
#remove first row and set new names
CAZy_for_heat <- CAZy_for_heat[-1, ]
colnames(CAZy_for_heat) <- new_colnames
#remove annos
CAZy_for_heat_no_anno <- data.frame(CAZy_for_heat[-1, ])
#convert to numeric
CAZy_for_heat_no_anno[] <- lapply(CAZy_for_heat_no_anno, as.numeric)
#remove cols with all zero values using dplyr
CAZy_for_heat_no_anno_no_z <- CAZy_for_heat_no_anno %>% select_if(~ !all(. == 0))

dim(CAZy_for_heat_no_anno)
dim(CAZy_for_heat_no_anno_no_z) #removed 3 cols. 

#create mapping file for easy access to annotations 
CAZy_map<- cbind(CAZy_family = names(as.data.frame(CAZy_for_heat)), anno = CAZy_for_heat[1,])


#### plot CAZYmes onto heat map ####
#remove all sub categories
keep<- c("AA", "CBM", "CE", "EXPN", "GH", "GT", "Myosin motor", "PL")
only_parents<- CAZy_for_heat_no_anno_no_z[, names(CAZy_for_heat_no_anno_no_z) %in% keep]

##note, I'm using complexheatmap here for more mapping flexibility, in the tree order previously defined
#extract to map counts onto heatmap
row_totals <- rowSums(only_parents)

#Extract tip order to arrange rows in heatmap
p<-ggtree(tree)
tip_order <- rev(p$data %>% filter(isTip) %>% arrange(y) %>% pull(label))

#scale data for easier viewing by column: note, this isn't really necessary when looking at each category individually,
#but looking them all at once makes them dificult to interpret without normalization because of the variance between categories.
scaled_only_parents = scale(only_parents)


###to investigate each family individually 
#Function to find parents with children
find_parents_with_children <- function(names) {
  parents <- unique(gsub("_[^_]+$", "", names[grep("_", names)])) # Extract parent terms from children
  parents_with_children <- parents[parents %in% names] # Keep parents that are in the original list
  return(parents_with_children)
}


#pull column names
column_names<- names(CAZy_for_heat_no_anno_no_z) 
length(column_names) #125

#get the parent column names that have children
parents_w_children <- find_parents_with_children(column_names)
length(parents_w_children) #9

#list everything else that doesn't have children
parents_wo_children <- setdiff(column_names, parents_w_children)
length(parents_wo_children)

#subset remove the parent columns (but not the children)
no_parents <- CAZy_for_heat_no_anno_no_z[, parents_wo_children] #note, this still contains the totals columns though


##split by family and remove the columns that total the children
families<- c("AA", 
             "CBM",
             "CE",
             "EXPN",
             "GH",
             "GT",
             "Myosin_motor",
             "PL")

#make a list of data frames by splitting based on family (removing the column that contains the totals, and have the same col names as the families list)
no_parents_split <- lapply(families, function(term) {
  cols <- grep(term, names(no_parents), value = TRUE)
  df_temp <- no_parents[, cols, drop = FALSE]
  if (length(cols) > 1 && term %in% names(df_temp)) {
    df_temp <- df_temp[, -which(names(df_temp) == term), drop = FALSE]
  }
  df_temp
})


#assign names to the dataframes to access them later
names(no_parents_split) <- families[1:length(no_parents_split)]



#graph AA

#scale data for easy viewing
#scaled_only_parents = scale(only_parents)

##GO BACK How to deal with cingle col dfs and cols where all vals are 1?
#use scale function on each dataframe in the list
#scaled_no_parents_split <- lapply(no_parents_split, scale)

# Rename scaled dataframes and store them in a new list
#scaled_no_parents_split <- lapply(names(scaled_dfs), function(name) {
#  df_scaled <- scaled_dfs[[name]]
#  new_name <- paste0(name, "_scaled")
#  names(df_scaled) <- paste0(names(df_scaled), "_scaled")
#  list(new_name = df_scaled)
#})

# Convert the list of lists into a single list
#scaled_no_parents_split <- do.call(c, scaled_no_parents_split)


#extract to map counts onto heatmap
#row_totals_AA <- rowSums(no_parents_split[[1]]) IF normalizing - otherwise you can use the counts directly.




#define function for heatmap
heatmap_with_annotation <- function(z, col_fun) {
  cell_size <- unit(6, "mm")  #set the cell size for consistency between plots
  
  Heatmap(as.matrix(z), 
          name = "relative abundance \nper CAZYme family", 
          col = col_fun,
          rect_gp = gpar(col = "white", lwd = 2),  #white borders around each cell
          column_title = "CAZYme", 
          column_title_side = "bottom",
          column_names_rot = 45,
          column_title_gp = gpar(width = .5),
          cluster_columns = FALSE,  #keep columns in the same order as the original data matrix
          show_row_dend = FALSE,  #hide the row dendrogram
          show_column_dend = FALSE,  #hide the column dendrogram
          row_order = match(tip_order, rownames(z)),
          row_names_gp = gpar(fontface = "italic"),
          top_annotation = HeatmapAnnotation("total per \nCAZYme family" = anno_points(colSums(z)), height = unit(10, "mm")), 
          right_annotation = rowAnnotation("total per \nspecies" = anno_barplot(rowSums(z), width = unit(20, "mm"))), 
          width = ncol(z) * cell_size,  #set width based on the number of columns and cell size
          height = nrow(z) * cell_size,  #set height based on the number of rows and cell size
          layer_fun = function(j, i, x, y, width, height, fill) {
            #vectorized grid.text
            grid.text(sprintf("%d", pindex(as.matrix(z), i, j)), x, y, 
                      gp = gpar(fontsize = 10))
          })
}


#if you scale, use this function because you need a float
#plot heatmap of CAZYme scaled data
#heatmap_with_annotation_scale <- function(z, col_fun) {
#  cell_size <- unit(6, "mm")  #set the cell size for consistency between plots
#  
#  Heatmap(as.matrix(scaled_only_parents), 
#          name = "relative abundance \nper CAZYme family", 
#          col = col_fun,
#          rect_gp = gpar(col = "white", lwd = 2), # Set white borders around each cell
#          column_title = "CAZYme", 
#          column_title_side = "bottom",
#          column_names_rot = 45,
#          cluster_columns = FALSE, #so that cols are in the same order as in the OG data matrix (in this case alphabetical)
#          show_row_dend = FALSE, #hide the row dendrogram
#          show_column_dend = FALSE, #hide the column dendrogram
#          row_order = match(tip_order, rownames(only_parents)),
#          row_names_gp = gpar(fontface = "italic"),
#          top_annotation = HeatmapAnnotation("total per \nCAZYme family" = anno_points(colSums(only_parents)), height = unit(10, "mm")), #note, we don't include this in the function here, becuase we need the non-scaled data
#          right_annotation = rowAnnotation("total per \nspecies" = anno_barplot(rowSums(only_parents), width = unit(20, "mm"))), 
#          #width = ncol(z) * cell_size,  #set width based on the number of columns and cell size
#          #height = nrow(z) * cell_size,  #set height based on the number of rows and cell size
#          height = 6, #set hard values
#          width = 6,
#          layer_fun = function(j, i, x, y, width, height, fill) {
#            #this is the vectorized grid.text
#            grid.text(sprintf("%d", pindex(as.matrix(only_parents), i, j)), x, y, 
#                      gp = gpar(fontsize = 10))
#          })
#}



##graph all cazy totals together

# Define the seven colors
colors <- c("#005E54", "#C2BB00", "#E1523D","#540354", "#ED8B16", "#407C98", "#FFC818")

# Create a list of color functions, one for each column
col_funs <- lapply(colors, function(color) {
  colorRamp2(c(min(scaled_only_parents), max(scaled_only_parents)), c("#FFFFFF", color))
})

cazy_names<- c("AA","CBM","CE","EXPN","GH","GT","PL")

All_fig<- Heatmap(scaled_only_parents, 
        name = "relative abundance \nper CAZYme family", 
        rect_gp = gpar(type = "none", col = "white", lwd = 2), #Set white borders around each cell
        column_title = "CAZYme", 
        column_title_side = "bottom",
        column_names_rot = 45,
        cluster_columns = FALSE,  # Keep columns in the same order as the original data matrix
        show_row_dend = FALSE,  # Hide the row dendrogram
        show_column_dend = FALSE,  # Hide the column dendrogram
        row_order = match(tip_order, rownames(scaled_only_parents)),
        row_names_gp = gpar(fontface = "italic"),
        top_annotation = HeatmapAnnotation("total per \nCAZYme family" = anno_points(colSums(only_parents)), height = unit(10, "mm")),  # Note: using non-scaled data
        right_annotation = rowAnnotation("total per \nspecies" = anno_barplot(rowSums(only_parents), width = unit(20, "mm"))), 
        height = 6, #set hard values
        width = 6, #set hard values
        
        #set splits to color ea col individually
        column_split = cazy_names,
        layer_fun = function(j, i, x, y, w, h, fill) {
          # transform the matrix into a long vector
          #v = pindex(m, i, j) 
          v = pindex(as.matrix(scaled_only_parents), i, j)
          
          # `j` here is also a vector with the same length of `v`
          col = ifelse(cazy_names[j] == "AA", col_funs[[1]](v),
                       ifelse(cazy_names[j] == "CBM", col_funs[[2]](v), 
                              ifelse(cazy_names[j] == "CE", col_funs[[3]](v), 
                                     ifelse(cazy_names[j] == "EXPN", col_funs[[4]](v),
                                            ifelse(cazy_names[j] == "GH", col_funs[[5]](v),
                                                   ifelse(cazy_names[j] == "GT", col_funs[[6]](v),
                                                          ifelse(cazy_names[j] == "PL", col_funs[[7]](v),
                                                                 col_fun_c(v))))))))
          
          grid.rect(x, y, w, h, gp = gpar(fill = col, col = col))
          
          #this is the vectorized grid.text
          grid.text(sprintf("%d", pindex(as.matrix(only_parents), i, j)), x, y, 
                    gp = gpar(fontsize = 10, col = "black"))
        }, 
        show_heatmap_legend = FALSE)

All_fig


#render CAZys individually by family

#AA heatmap
col_fun_AA = colorRamp2(c(min(no_parents_split[[1]]), max(no_parents_split[[1]])), c("#FFFFFF", "#005E54"))
AA_fig<- heatmap_with_annotation(z = no_parents_split[[1]], col_fun = col_fun_AA)
AA_fig

#CBM heatmap - Suipic has so many CBM13
col_fun_CBM = colorRamp2(c(min(no_parents_split[[2]]), max(no_parents_split[[2]])), c("#FFFFFF", "#C2BB00"))
CBM_fig<- heatmap_with_annotation(z = no_parents_split[[2]], col_fun = col_fun_CBM)
CBM_fig

#CE heatmap
col_fun_CE = colorRamp2(c(min(no_parents_split[[3]]), max(no_parents_split[[3]])), c("#FFFFFF", "#E1523D"))
CE_fig<- heatmap_with_annotation(z = no_parents_split[[3]], col_fun = col_fun_CE)
CE_fig

#EXPN heatmap
col_fun_EXPN = colorRamp2(c(min(no_parents_split[[4]]), max(no_parents_split[[4]])), c("#FFFFFF", "#540354"))
EXPN_fig<- heatmap_with_annotation(z = no_parents_split[[4]], col_fun = col_fun_EXPN)
EXPN_fig

#GH heatmap - need to fix scaling - too many categories
col_fun_GH = colorRamp2(c(min(no_parents_split[[5]]), max(no_parents_split[[5]])), c("#FFFFFF", "#ED8B16"))
GH_fig<- heatmap_with_annotation(z = no_parents_split[[5]], col_fun = col_fun_GH)
GH_fig
#totals: 
sort(colSums(no_parents_split[[5]]))

#GT heatmap - need to fix scaling - too many categories
col_fun_GT = colorRamp2(c(min(no_parents_split[[6]]), max(no_parents_split[[6]])), c("#FFFFFF", "#407C98"))
GT_fig<- heatmap_with_annotation(z = no_parents_split[[6]], col_fun = col_fun_GT)
GT_fig
#totals: 
sort(colSums(no_parents_split[[6]]))
#get averages 
colMeans(no_parents_split[[6]])
#remove Suilu4 and recalculate
df_temp<- no_parents_split[[6]]
dim(df_temp)
df_indexed <- df_temp[rownames(df_temp) != "Suilu4", ]
colMeans(df_indexed)

#Myosin_motor heatmap - need to fix  brakes with one col
#col_fun_Myosin_motor = colorRamp2(c(min(no_parents_split[[7]]), max(no_parents_split[[7]])), c("#FFFFFF", "#035448"))
#heatmap_with_annotation(z = no_parents_split[[7]], col_fun = col_fun_Myosin_motor)
#exclude these - not relevent to this study, and no variance.

#PL heatmap - need to fix scaling - too many categories
col_fun_PL = colorRamp2(c(min(no_parents_split[[8]]), max(no_parents_split[[8]])), c("#FFFFFF", "#FFC818"))
PL_fig<- heatmap_with_annotation(z = no_parents_split[[8]], col_fun = col_fun_PL)
PL_fig


##print figs
#pdf("All_fig.pdf", width = 6, height = 5)
#draw(All_fig)
#dev.off()

#pdf("AA_fig.pdf", width = 15, height = 4)
#draw(AA_fig)
#dev.off()

#pdf("CBM_fig.pdf", width = 15, height = 4)
#draw(CBM_fig)
#dev.off()

#pdf("CE_fig.pdf", width = 15, height = 4)
#draw(CE_fig)
#dev.off()

#pdf("EXPN_fig.pdf", width = 15, height = 4)
#draw(GH_fig)
#dev.off()

#pdf("GH_fig.pdf", width = 15, height = 4)
#draw(GH_fig)
#dev.off()

#pdf("GT_fig.pdf", width = 15, height = 4)
#draw(GT_fig)
#dev.off()

#pdf("PL_fig.pdf", width = 15, height = 4)
#draw(PL_fig)
#dev.off()



###update CAZYme figure with only chitin relevant CAZyymes###
#subset cazyme map to only cazymes in the dataset
CAZY_MAP_small <- CAZY_MAP %>%
  semi_join(CAZy, by = c("sub_fam" = "Annotation"))

#remove any anabolic processes (include NAs)
CAZY_MAP_small_cat <- CAZY_MAP_small %>%
  filter(is.na(`metabolic key`) | str_detect(`metabolic key`, "catabolic"))



#For this manuscript we're really just interestd in CAZymes acting on Chitin. We are going to use an in-house curated database to investigate only these gene families.
#in the database, the following gene families are associated with Chitin metabolism:

enzyme_list<- c("Chitinase (EC 3.2.1.14)",
                "Chitin exo-β-1,4-N-acetylglucosaminidase (EC 3.2.1.-)",
                "Di-N-acetylchitobiase / reducing-end exo-hexosaminidase (EC 3.2.1.-)",
                "Chitin exo-β-1,4-N-acetylglucobiosaminidase (EC 3.2.1.200)",
                "[reducing end] exo-chitinase (EC 3.2.1.201)",
                "Chitosanase (EC 3.2.1.132)",
                "Exo-β-1,4-glucosaminidase (EC 3.2.1.165)",
                "Chitin β-1,3/1,6-glucanosyltransferase (EC 2.4.1.-)",
                "β-1,6-N-acetylglucosaminidase (EC 3.2.1.-)",
                "β-N-acetylhexosaminidase (EC 3.2.1.52)",
                "Chitin deacetylase (EC 3.5.1.41)",
                "Chitin oligosaccharide deacetylase (EC 3.1.1.-)",
                "N-acetylglucosamine-6-phosphate deacetylase (EC 3.5.1.25)",
                "Lytic chitin monooxygenase (EC 1.14.99.53)")


CAZY_MAP_chitin <- CAZY_MAP_small_cat[sapply(CAZY_MAP_small_cat$annotation, function(x) any(sapply(enzyme_list, function(y) grepl(y, x, fixed = TRUE)))), ]
CAZY_MAP_chitin
#need to remove GH5 - chitin active subfamilies not present

##add in CBMs (these are non-catalytic and don't have enzyme annotations)
#subset chitin-binding CBMs
CBMs<-CAZY_MAP_small_cat[
  CAZY_MAP_small_cat$parent_family == "CBM" &
    (grepl("chitin|chitosan|chitobiose", CAZY_MAP_small_cat$substrate, ignore.case = TRUE)),
]
#add to larger dataset
CAZY_MAP_chitin<- rbind(CBMs, CAZY_MAP_chitin)


#remove the family totals from the main DF
no_parents<- no_parents[, !colnames(no_parents) %in% families]

#subset df to only CAZyme families relevant to chitin metabolism
chitin_CAZyme_counts<- no_parents[, colnames(no_parents) %in% CAZY_MAP_chitin$sub_fam]
ncol(chitin_CAZyme_counts)
length(CAZY_MAP_chitin$sub_fam) #note we are excluding GH5 here, as the sub families thought to have chitin degradation capacity are not present in the 6 species under investigation.

###
#change datatype to matrix
chitin_CAZyme_counts<- as.matrix(chitin_CAZyme_counts)

#scale data for easier viewing - do this be category so the scale starts over for each color
#start by splitting each category
CBM <- chitin_CAZyme_counts[, grep("CBM", colnames(chitin_CAZyme_counts))]
CE<- chitin_CAZyme_counts[, grep("CE", colnames(chitin_CAZyme_counts))]
GH<- chitin_CAZyme_counts[, grep("GH", colnames(chitin_CAZyme_counts))]

#set color scale for each 
CBM_col_scale = colorRamp2(c(min(CBM)-2, max(CBM)), c("#FFFFFF", "#C2BB00"))
CE_col_scale = colorRamp2(c(min(CE)-2, max(CE)), c("#FFFFFF", "#005E54"))
GH_col_scale = colorRamp2(c(min(GH)-2, max(GH)), c("#FFFFFF", "#FFC818"))

colSums(chitin_CAZyme_counts)

cazy_names2<- colnames(chitin_CAZyme_counts)
desired_column_order <- c("CBM5", "CBM12", "CBM18", "CBM50", "CE4", "CE9", "GH2", "GH3", "GH9", "GH16", "GH18", "GH20", "GH23", "GH35")


#Define the cell size
cell_size <- unit(7, "mm")  # Change this to your desired cell size

#Create the heatmap
chitin_fig <- Heatmap(
  chitin_CAZyme_counts, 
  name = "relative abundance \nper CAZYme family", 
  rect_gp = gpar(type = "none", col = "white", lwd = 2),  #Set white borders around each cell
  column_title = "CAZYme", 
  column_title_side = "bottom",
  column_names_rot = 45,
  cluster_columns = FALSE,  #Keep columns in the same order as the original data matrix
  show_row_dend = FALSE,  #Hide the row dendrogram
  show_column_dend = FALSE,  #Hide the column dendrogram
  row_order = match(tip_order, rownames(chitin_CAZyme_counts)),
  row_names_gp = gpar(fontface = "italic"),
  top_annotation = HeatmapAnnotation(
    "total per \nCAZYme family" = anno_points(colSums(chitin_CAZyme_counts)),
    height = unit(15, "mm")
  ),  
  right_annotation = rowAnnotation(
    "total per \nspecies" = anno_barplot(rowSums(chitin_CAZyme_counts), width = unit(20, "mm"))
  ), 
  
  height = nrow(chitin_CAZyme_counts) * cell_size,  #Set height of cells
  width = ncol(chitin_CAZyme_counts) * cell_size,   #Set width of cells
  
  column_split = factor(colnames(chitin_CAZyme_counts), levels = desired_column_order),
  column_order = order(factor(colnames(chitin_CAZyme_counts), levels = desired_column_order)),  # Set the column order here
  
  cell_fun = function(j, i, x, y, width, height, fill) {
    v <- as.matrix(chitin_CAZyme_counts)[i, j]
    
    # Define the color scaling function based on column names
    col <- ifelse(cazy_names2[j] == "CBM5", CBM_col_scale(v),
                  ifelse(cazy_names2[j] == "CBM12", CBM_col_scale(v),
                         ifelse(cazy_names2[j] == "CBM18", CBM_col_scale(v),
                                ifelse(cazy_names2[j] == "CBM50", CBM_col_scale(v),
                                       ifelse(cazy_names2[j] == "CE4", CE_col_scale(v),
                                              ifelse(cazy_names2[j] == "CE9", CE_col_scale(v),
                                                     ifelse(cazy_names2[j] == "GH2", GH_col_scale(v),
                                                            ifelse(cazy_names2[j] == "GH3", GH_col_scale(v),
                                                                   ifelse(cazy_names2[j] == "GH9", GH_col_scale(v),
                                                                          ifelse(cazy_names2[j] == "GH16", GH_col_scale(v),
                                                                                 ifelse(cazy_names2[j] == "GH18", GH_col_scale(v),
                                                                                        ifelse(cazy_names2[j] == "GH20", GH_col_scale(v),
                                                                                               ifelse(cazy_names2[j] == "GH23", GH_col_scale(v),
                                                                                                      ifelse(cazy_names2[j] == "GH35", GH_col_scale(v),
                                                                                                      col_fun_c(v)))))))))))))))
    
    grid.rect(x, y, width, height, gp = gpar(fill = col, col = col))
    
    #Add text here
    grid.text(sprintf("%d", as.matrix(chitin_CAZyme_counts)[i, j]), x, y, 
              gp = gpar(fontsize = 10, col = "black"))
  }, 
  show_heatmap_legend = FALSE
)

#Print the heatmap
chitin_fig

#pdf("chitin_fig.pdf", width = 8, height = 4)
#draw(chitin_fig)
d#ev.off()


### some quick stats ### 
#total chitin-active gene count overall 
total_cazymes_per_family<- colSums(chitin_CAZyme_counts)
sum(total_cazymes_per_family) #474 in total
sort(total_cazymes_per_family)

#sum of CBMs
sum_CBM <- sum(total_cazymes_per_family[grep("^CBM", names(total_cazymes_per_family))])
sum_CBM

#sum of CEs
sum_CE <- sum(total_cazymes_per_family[grep("^CE", names(total_cazymes_per_family))])
sum_CE

#sum of GHs
sum_GH <- sum(total_cazymes_per_family[grep("^GH", names(total_cazymes_per_family))])
sum_GH

#make sure that math makes sense
sum_CBM+sum_CE+sum_GH #474 - looks good

#get total chitin-active gene counts per species
ea_sp<- rowSums(chitin_CAZyme_counts)
sort(ea_sp)
#S. weaverae       S. luteus   S. americanus S. clintonianus   S. ampliporus     S. spraguei 
#67              74              77              81              82              93 

